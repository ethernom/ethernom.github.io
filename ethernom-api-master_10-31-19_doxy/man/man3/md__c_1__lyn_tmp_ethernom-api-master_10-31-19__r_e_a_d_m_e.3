.TH "md__c_1__lyn_tmp_ethernom-api-master_10-31-19__r_e_a_d_m_e" 3 "Fri Nov 1 2019" "EtherAPI" \" -*- nroff -*-
.ad l
.nh
.SH NAME
md__c_1__lyn_tmp_ethernom-api-master_10-31-19__r_e_a_d_m_e \- Installation: 
From your command line: 
.PP
.nf
cd -> directory

# Clone the ethernom-api repository to the root directory
# Open package\&.json
# Add back: "ethernom-api":"1\&.0\&.0"

.fi
.PP
.PP
.SS "API CALLS:"
.PP
.SS "How-To: Initialize EthernomAPI:"
.PP
Parameter: {
.br
 transportType = 'USB', 'BLE' & 'NFC',
.br
 API_ID = 0x00 ~ 0xFF,
.br
 secsTimeout = -1 (Doesn't timeout) or possitive integer,
.br
 allowDuplicates = true or false,
.br
 stopScanOnWrite = true or false,
.br
 Callback function
.br
 }
.br
 Callback: resultCode 
.PP
.nf
import {EthernomAPI} from "ethernom-api";
var MAIN_E_API = new EthernomAPI(transportType, API_ID, secsTimeout, allowDuplicates, stopScanOnWrite, (resultCode) =>{
    if (resultCode == ETH_SUCCESS){
        //Initialize success
        MAIN_E_API\&.DiscoverDevices(this\&._device_discovery);
        /*
        \&.\&.\&.
        Can start using other EthernomAPI calls
        \&.\&.\&.
        \&.\&.\&.
        */
    }else{
        //Initialize fail
    }
});

.fi
.PP
 
.br
.PP
.SS "How-To: Discovery devices:"
.PP
Parameter: Callback function
.br
 Callback: resultCode, deviceID and deviceName 
.PP
.nf
MAIN_E_API\&.DiscoverDevices(this\&._device_discovery);

_device_discovery = (resultCode, deviceID, deviceName) => {
    console\&.log(deviceID);
    console\&.log(deviceName):
}

.fi
.PP
 
.br
.PP
### How-To: Stop discovery devices: 
.PP
.nf
MAIN_E_API\&.StopDiscovery();

.fi
.PP
 
.br
.PP
.SS "How-To: Select/Connect devices:"
.PP
When want to select/connect to a devices, create a new EthernomAPI instaces to handle the connection\&.
.br
 Parameter: deviceID, deviceName & Callback function
.br
 Callback: resultCode 
.PP
.nf
var E_API = new EthernomAPI(transportType, API_ID, 0, false, true, (resultCode) => {
    if (resultCode == ETH_SUCCESS){
        this\&._device_select(resultCode, deviceID, deviceName, E_API);
    }else{
        //Fails initialize
    }
});

_device_select = (resultCode, deviceID, deviceName, E_API) => {
    E_API\&.Select(deviceID, deviceName, (resultCode) =>{
        if (resultCode == ETH_SUCCESS){
            /*
            \&.\&.\&.
            Can start write/read card
            \&.\&.\&.
            */
        }else{
            //Fails select
        }
    }
}

.fi
.PP
 
.br
.PP
.SS "How-To: Write to devices:"
.PP
Parameter: Inbound Message Struct, Outbound Message Struct & Callback function
.br
 Callback: resultCode and Inbound Message 
.PP
.nf
//Options for Outbound message variable types are: ETH_STRING_AS_UNICODE, ETH_STRING_AS_ASUTF8, ETH_INT_AS_BYTE & ETH_INT_AS_2BYTE
//Outbound message is what will be send to the car
//Each parameter must contains the value
var out_msg = {
    command: {
        encoding: ETH_INT_AS_BYTE,
        value: TRK_H2C_INIT
    },
    PARAMETER1: {
        encoding: ETH_STRING_AS_ASTUF8,
        value: "STRING_VALUE";
    },
    PARAMETER2: {
        encoding: ETH_STRING_AS_UNICODE,
        value: "汉字";
    },
    PARAMETER3: {
        encoding: ETH_INT_AS_2BYTE,
        value: integer (0 ~ 65535);
    },
    PARAMETER4: {
        encoding: ETH_INT_AS_BYTE,
        value: integer (0 ~ 255);
    }
}

//Options for Inbound message variable types are: ETH_UNICODESTRING, ETH_UTF8STRING, ETH_BYTE, ETH_2BYTE, ETH_PAYLOAD
//Inbound message is to define to what's the expected value back from the card, when the EthernomAPI receives the message from card\&. 
//The EthernomAPI will know which value belongs to which parameter
var in_msg  = {
    command : ETH_BYTE,
    PARAMETER1: ETH_BYTE,
    PARAMETER2: ETH_2BYTE,
    PARAMETER3: ETH_UTF8STRING,
    PARAMETER4: ETH_UNICODESTRING,
    PAYLOAD: ETH_PAYLOAD (Optional)
}

E_API\&.WriteJSON(out_msg, in_msg, (resultCode, msg) => {
    if(resultCode == ETH_SUCCESS){
        console\&.log(msg\&.command):
        console\&.log(msg\&.PARAMETER1):
        console\&.log(msg\&.PARAMETER2):
        console\&.log(msg\&.PARAMETER3):
        console\&.log(msg\&.PARAMETER4):
        console\&.log(msg\&.PAYLOAD):
    }else{
        //Fails write
    }
}

.fi
.PP
 
.br
.PP
.SS "How-To: Subscribe to unsolicted events:"
.PP
Parameter: deviceID, deviceName, Inbound Message Struct, Callback function
.br
 Callback: resultCode and Inbound Message 
.PP
.nf
E_API\&.SubscribeToUnsolictedEvents(deviceID, deviceName, in_msg, this\&._on_listener);

_on_listener = (deviceID, deviceName, resultCode, msg) => {
    console\&.log(deviceID);
    console\&.log(deviceName);
    console\&.log(msg);
}

.fi
.PP
.PP
### How-To: Unsubscribe to unsolicted events: 
.PP
.nf
E_API\&.UnSubscribeToUnsolictedEvents();

.fi
.PP
 
.br
.PP
.SS "How-To: Card close:"
.PP
Parameter: Callback function
.br
 Callback: resultCode 
.PP
.nf
E_API\&.CardClose(this\&._callback_disconnect);

_callback_disconnect = (resultCode) => {
    if (resultCode == ETH_SUCCESS){
        console\&.log("Disconnect successfully");
    }else{
        console\&.log("Fails");
    }
}

.fi
.PP
 
